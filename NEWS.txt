GT NEWS
=======

==============
=== GT 3.0 ===
==============

New Functionality:

  * Millipede-style packet recording and replay: Thanks to a code
    contribution from Adrian Reetz, GT now has a packet recording/replay
    framework inspired by the Millipede sequential debugging module.

      * GT-Millipede is enabled by wrapping a connector or acceptor
	with a MillipedeConnector and MillipedeAcceptor with a
	configured instance of a MillipedeRecorder (which is either in
	recording or replaying mode)

      * There is a singleton MillipedeRecorder instance, which can have
	its mode set configured dynamically through an environment
	variable GTMILLIPEDE.  The 'Unconfigured' (the default) and
	'PassThrough' modes cause the use of Millipede to be skipped
	entirely, avoiding all effects on performance.

      * The DefaultClientConfiguration and DefaultServerConfiguration
	now wrap the connectors and acceptors using singleton
	MillipedeRecorder.  Thus any apps that use these configurations
	will ship with GT-Millipede debugging capabilities.

    See <https://papyrus.usask.ca/trac/gt/ticket/45> for details
    and pointers for other work.

  * Support for a large-object sending marshaller.  This functionality
    has necessitated some changes to the marshaller APIs; see below
    for details.

  * GT now uses the open-source Common.Logging package (v1.2.0) for
    logging messages.  Control-flow information is reported at the
    "Trace" level, and informational, warning, and errors are
    reported via the "Info", "Warn", and "Error" levels. 
    Common.Logging provides a simple abstraction to allow selecting
    a logging implementation at runtime (either programmatically
    or via the .NET App.Config mechanism).  For details on use, see
    the documentation at:

	http://netcommon.sourceforge.net/

    By default, Common.Logging uses a NoOpLoggerFactoryAdapter which
    supresses all output.  See section 1.3.2 of the Common.Logging
    reference manual for simple instructions to cause logging to the
    console using the Common.Logging.Simple.ConsoleOutLogger.

    As a result of this change, GT is now much quieter with respect
    to messages written to the system console.

  * The ClientConfiguration and ServerConfiguration classes are now
    afforded the opportunity to configure (or even wrap or replace)
    new transport instances through a ConfigureTransport() method.
    (see BaseConfiguration.ConfigureTransport()).

  * New traffic shaping transport wrappers, LeakyBucketTransport and
    TokenBucketTransport, respectively implementing the leaky bucket
    and token bucket traffic shaping algorithms. 

      * LeakyBucketTransport wraps a provided transport and restricts
	the transport to sending a certain amount of data per time
	unit; the LBT will buffer up to a specified number of bytes,
	and any bytes in excess are discarded (and raising a
	TransportBackloggedWarning).

      * TokenBucketTransport also wraps a provided transport, but
        allows the transport to accumulate unused send capacity.
	This better supports bursty traffic.  In the TBT, all data
	is queued, and released as capacity becomes available.

    These wrappers are easily configured by overriding the new
    ConfigureTransport() method on the ClientConfiguration and
    ServerConfiguration (see BaseConfiguration).


Interoperability changes:
=========================

  * The LightweightDotNetSerializingMarshaller and
    DotNetSerializingMarshaller on-wire formats have changed, which
    will break compatibility with previous releases.  Previously
    these marshallers recorded the marshalled payload length using
    an adaptive scheme.  This meant that many message types had to
    be serialized to an interim buffer to determine the length, and
    then copied; this was rather wasteful.  To avoid this duplicate
    copy, the payload length is now a fixed-length value.  As a
    result, the internal requirement of
    LightweightDotNetSerializingMarshaller have changed such that
    the Marshal* methods are no longer responsible for encoding the
    payload length.


Developer-visible changes:
==========================

We have made numerous breaks with previous API to streamline GT
usage and reconcile inconsistencies, hence the bump from GT 2.0 to
GT 3.0.

  * Delegate changes:

      * The delegate GT.Net.ConnexionLifecycleNotification has been
        expanded to include the associated Communicator (Client or Server)

      * The delegate GT.Net.TickHandler has been removed and replaced
	with System.Action<Communicator>, whose argument is the
	Communicator instance.

      * Replaced uses of GT.Net.{Session,String,Object,Binary}MessageHandler
        delegates with the equivalent GT.Net.MessageHandler

      * We reworked the IStream implementations to reduce code duplication. 
	As a result, we replaced the GT.Net.{Session,String,Object,
	Binary}NewMessageEvent delegates with the equivalent
	IAction<ST> where ST is the appropriate IStream subinterface.

      * The delegate GT.Net.PingReceived's time component now
	returns the round-trip ping time, and not half of the time.

      * The delegate GT.Net.NewClientHandler has been renamed to
	NewTransportHandler to better reflect its purpose, and had
	its second argument changed to pass an IDictionary, instead
	of a Dictionary.

  * Event changes:

      * As part of reworking the IStream implementations, the actual 
        new-message events have been renamed to MessagesReceived
	to be more consistent with similar events defined elsewhere.
	The Streamed Tuple implementations continue to use
	StreamedTupleReceived however.

  * ITransport changes:

      * The ITransport.SendPacket() methods have been consolidated
	into a single method taking a TransportPacket.  This is a
	generalized class for representing growable and splittable
	byte arrays, intended to support more memory-conscious
	operation and avoid generating garbage.

      * ITransport.MaximumPacketSize is now a uint and each transport must
	support setting this value.  The transport may silently cap
	this value at some transport-specific maximum.  TcpTransport
	and BaseUdpTransport's CappedPacketSize have been renamed to
	DefaultMaximumPacketSize.

      * ITransports no longer throw TransportBackloggedWarning, and
        instead provide such warnings through a new ErrorEvent event.

  * IMarshaller changes:

      * IMarshaller.Marshal() now returns an instance of IMarshalledResult,
        and should allocate instances of TransportPacket to record the
	marshalled values.  This new class is to add support for
	marshalling messages that are too large to fit into a single
	transport-level packet, or for marshallers that wish to
	stream objects.  TransportPacket.AsWriteStream() will produce
	a writeable, resizable stream.

      * IMarshaller's Unmarshal() method has been changed to use an
	delegate to notify of a message having become available.
	This change was necessary to support marshallers that may
	buffer incoming packets before reassembling messages, such
	as the LargeObjectMarshaller (if packets are received out
	of order).

      * IMarshaller.Marshal() and Unmarshal() now are now provided an
        ITransportDeliveryCharacteristics rather than an ITransport.
	The instance may be the actual transport, but this is not
	guaranteed.

      * Marshallers that cannot deal with splitting their result into
        multiple packets should not check their resulting packet
	lengths against the transport's maximum packet size.  We
	now provide a LargeObjectMarshaller that wraps another
	marshaller and performs the appropriate splitting to and
	reassembling from multiple packets.

  * The scheduling of messages into packets to be sent has been
    extracted from the connexion implementations into a new type called
    IPacketScheduler.  Two implementations are currently provided:
    RoundRobinPacketScheduler processes the channels in  a round-robin
    order, whereas ImmediatePacketScheduler processing messages
    on a first-come, first-served basis.  Packet schedulers are
    created by connexion instances.

  * There have been some major renames:

      * Message.Id has been renamed Channel.  The use of 'id' was
	somewhat ambiguous and causing confusion.  All uses of 'id' to
	mean a channel id or a stream id have been redone to use channel. 
	Described in <https://papyrus.usask.ca/trac/gt/ticket/74>.

      * The use of UniqueIdentity has been renamed to simply Identity. 
	  * IConnexion.UniqueIdentity -> Identity
	  * IStream.UniqueIdentity -> Identity
	  * GTCapabilities.CLIENT_ID -> CLIENT_GUID
	Although the identity value is unique between clients
	attached to the same server, the values are not globally
	unique.  Clients *do* have a 'Guid' property, however, which
	is communicated to the server.

      * GT.Net.BaseAcceptor has been renamed to IPBasedAcceptor,
	to reflect its IP-centric implementation.

      * GT.Net.IAcceptor's NewClientEvent event has been renamed
	to NewTransportAccepted.

      * As part of the renames, some non-API but possibly visible classes
	have also been renamed for clarity:

	  * To better reflect their intentions:
	      ClientConnexion -> ConnexionToClient
	      ServerConnexion -> ConnexionToServer
		* 'server' field -> 'owner' to match ConnexionToClient

  * Other changes:

      * Times have been moved to be specified using System.TimeSpan
	instances.  Notable changes include to the Sleep() methods on
	GT.Net.Client and GT.Net.Server, GT.Net.DefaultServerConfiguration,
	the tuple stream methods on GT.Net.Client, GT.Net.PingedNotification,
	GT.Net.DelayedBinaryStream, and GT.Net.AggregatedSharedDictionary.

      * The Sleep() implementations on GT.Net.Client and GT.Net.Server
	now return a boolean to indicate whether the sleep executed
	without interruption.  Future versions of GT may provide some
	method for event processing during Sleep().

      * GT.Net.Client and GT.Net.Server have been reworked and had common
	code extracted to a common subclass, GT.Net.Communicator.

      * Clients and Servers now log a warning when there are no registered
	ErrorEvent handlers.


Bugs have been fixed since GT 2.0:
==================================

  * Server.UpdateAcceptors() threw an NullRefEx as it wasn't properly
    handling case where an acceptor was inactive but the first to 
    be removed.

  * Add lock() around FlushChannelMessages (called by IStream.Flush())
    <https://papyrus.usask.ca/trac/gt/ticket/66>.

  * ClientRepeater configuration should use TickInterval, not 
    PingInterval!  <https://papyrus.usask.ca/trac/gt/ticket/64>

  * Allow Server instances to be stopped and restarted by not nilling
    clientIDs in KillAll()  <https://papyrus.usask.ca/trac/gt/ticket/60>

  * Wrap TcpTransport.ToString() to avoid throwing exceptions on
    invalid handles.

  * Ensure Server and Client are started at the end of
    StartSeparateListeningThread() <https://papyrus.usask.ca/trac/gt/ticket/56>

  * Client.Get*Stream(): check that streams are still active
    <https://papyrus.usask.ca/trac/gt/ticket/71>

  * Expose an IStream's connexion through a Connexion property

  * UdpAccept and TcpAcceptor should now properly trap and report
    exceptions <https://papyrus.usask.ca/trac/gt/ticket/55>

  * Ensure IConnexion.MessageSent event is sent for aggregated
    messages.  <https://papyrus.usask.ca/trac/gt/ticket/61>


==============
=== GT 2.0 ===
==============

GT 2.0 has undergone a significant re-architecturing from GT 1.0
to promote more flexibility and extensibility.  There have been a
number of breaking changes, primarily dealing with type renaming.

Breaking Changes:

  * As part of reorganizing the code, we've renamed the namespaces
    (GTServer and GTClient -> GT.Net) and introduced a new assembly to
    hold common components (GTBase). 
    <https://papyrus.usask.ca/trac/gt/ticket/7>

      * Change all the uses
	  'using GTServer;'  ->  'using GT.Net;'
	  'using GTClient;'  ->  'using GT.Net;'

      * You will need to add the GTBase project or DLL to your clients.
	<https://papyrus.usask.ca/trac/gt/ticket/13>

  * The TCP and UDP protocols have been separated out and generalized
    from the code into implementations called transports (see ITransport).
    The MessageProtocol enum has disappeared: clients now request 
    a communication protocol by describing the requirements for
    sending a message; GT will use these requirements to find a suitable
    transport.

  * Many classes have been shielded by interfaces, notably the *Stream
    classes provided by GT Client.  The Client.Get*Stream() methods now
    return interfaces (i.e., IStringStream, IBinaryStream, IObjectStream,
    ISessionStream, ITupleStream*).  The Client.GetStreamedTuple*()
    methods now also return interfaces (i.e., IStreamedTuple).

  * GT Server's Server.Client has been renamed to ClientConnexion,
    and similarly GT Client's ServerStream has been renamed to
    ServerConnexion.  These classes have been shielded behind an
    interface IConnexion.  Both classes have undergone cleanup:

      * the Dead property has been flipped to be called Active and
        made read-only;

      * IConnexion now implements IDisposable: any uses of Dead as
        a writable property should be changed to use IDisposable.Dispose().

      * the Send() calls now take both a MessageDeliverRequirements object
        and a ChannelDeliveryRequirements object (one of which can be
	null).  These objects encompass the different MessageAggregation,
	MessageOrder, and MessageProtocol values used previously.

  * Previously-exposed fields have been made into properties and
    some have been renamed to better conform to C#/.NET naming guidelines. 
    Most notable perhaps is Server.clientList -> Server.Clients.

  * AggregatingSharedDictionary and SimpleSharedDictionary have been
    have been changed to use IObjectStreams rather than a IBinaryStream.
    NOTE: AggregatingSharedDictionary is likely to disappear.

  * Some delegates have had their signatures changed to use the least
    specific collection classes possible
	ClientsRemovedHandler uses ICollection
	ClientsJoinedHandler uses ICollection

  * The marshalling code has been separated and servers and clients
    now deal in more abstract Messages.
    <https://papyrus.usask.ca/trac/gt/ticket/23>

      * delegate MessageHandler has a different calling convention

  * The message parameterization for Quality of Service has been
    reworked.  Many of the parameters previously specified on Send()
    are now properties associated on the channels.

  * Specialized GT exceptions have been created to represent different
    insurpassable communications conditions in GT.  These exceptions
    inherit from GTException.

      CannotConnectToRemoteException: a client experienced some problem
	connecting to a specified server.  It may be that there was
	a mistake in the identifying information for the server,
	the server may be down or unavailable, or there are routing
	difficulties (such as firewalls) that prevent connecting.
	Potentially thrown on Client.Start().  This exception may
	also be thrown on Send() for short-lived transports where
	connections are opened periodically rather that being
	long-lived (e.g., HTTP and SMTP),

      NoMatchingTransport: no transport could be found that supported
        the required QoS specifications.  Potentially thrown by the
	various flavours of Send().

  * Error reporting has changed somewhat dramatically.  The old
    ErrorEventHandler delegates are now a delegate named ErrorEventNofication:

	public delegate void ErrorEventNotication(ErrorSummary summary);

    The ErrorSummary object contains an assessment of the severity
    of the error, an actionable descriptive error code, and
    debugging information.

  * Client.StartListeningOnSeperateThread(int) has been renamed to
    Client.StartSeparateListeningThread() to be consistent with
    Server.  Both Client and Server's StartSeparateListeningThread()
    have had their tick-interval argument removed in favour of being
    specified using the configuration's TickInterval property.


New additions

  * Added a lifecycle protocol, IStartable, consisting of Start(),
    Stop(), and Dispose() methods, and a read-only property Active. 
    These methods have been added to most GT user-visible objects
    to respectively start, stop, and dispose of any system object. 
    <https://papyrus.usask.ca/trac/gt/ticket/22>
    
      * Client.StartListening() and Server.StartListening() both
        automatically Start() and Stop() their respective instances.
	This ensures that the clients and servers are closed in
	their normal usage.

      * Client.Update() and Server.Update() will automagically
	call Start() if their instance has not already been started.
	This behaviour is deprecated and will be removed in a future
	release.

  * Added Client.Sleep() and Server.Sleep() methods: these new methods
    provide a much more efficient way for servicing incoming messages
    while sleeping and greatly improve the fairness of servicing
    GT requests.

  * We have also introduced some new components in the GT.Utils and GT.UI
    namespaces.  The intent is to provide components that are helpful
    for quickly prototyping groupware apps.

  * We have added some handy events to notify of interesting situations:
      * notification of messages sent on server instances
      * notification of the addition and removal of connexions to
        client or server instances
      * notification of the addition and removal of transports from
        connexions. 
      * notification of ping-sent and ping-received on connexions for
        particular transports.

  * Began creating unit tests using NUnit <http://nunit.org>

Re-organized source code

  * Separated example programs from the core client and server
    components <https://papyrus.usask.ca/trac/gt/ticket/10>


